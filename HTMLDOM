
@String
at charAT codePointAt charCodeAt concat endWIth startWith trim trimLeft trimRight trimSTart trimENd padStart padEnd localeCompare
toLocaleUpperCase toLocaleLowerCAse toLowerCAse toUpperCase includes indexOf lastIndexOf slie split substring search reapeat replace
match martchAll toString valueOf 
@Number
toFixed toPrecison toString valueOf parseINt parseFloat isNaN isFinite isSafeInteger isInteger
@Array
at copyWithin concat every entries fill filter find findIndex flat fkatMap forEach join keys map includes indexOf lastIndexOf sort reverse
shift unshift slice splice pop push reduce reduceRight toSTring values
@OBject
assign create defineProperties defineProperty seal isSealed freeze isFrozrn preventExtensible isExtensible entries fromEntries is keys values toSTring
@Math
random round floor ceil min max trunc
@Classes
abstract implements extends interface private public protected readonly # ? ! constructor super this static
@Dates
getDate getDay getFullYEar getMonth getHpours getMinutes getSeconds getMIlliseconds getTime getTimezoneOffset getUTCDate getUtcDay
getUTCFullYEar getUtcMonth getUTCHours getUTCMinute sgetUTCSecondsgetUTCMilliseconds setDate seFullYear setMonth setHours setMinutes
setSeconds setMilliseconds setTime setUTCDate setUTCFullYear setUTCMonth setUTCHours setUTCMinutes setUTCSeconds setUTCMilliseconds
setTime toDateString toISOSTring toJSON toLoclaeSTring toLocaleTimeSTring toLoclaeDateString toUTCSTring toTimeSTring toSTring
@Regex
[] () | * + . ? ?= ?! ^ $ {n} {x|y} {x,} \w \W \d \D

1 activeElements
2 addEventListener() 
3 adopteNode() this method get element from another frame work like iframe
4 baseURI // return current url
4 body 
6 characterSet // return character encoded tyep like  UFT8
7 document.open 
8 document.write
9 document.close
10 cookie // return all cookies in a single string
11 createAttribute // create html element attribute 
12 setAttributeNode() // set html element attribute
13 createElement // this help to create dom element
14 textContent // with use that you can set elemnt text
15 createDocumentFragment // this help to store group elemnts and complete the task u can append into document element
16 appendChild // help to push element into dom element
?17 createEvent // create event ? 
18 defaultView
19 designMode // nice this allow to edit text on web when it on
20 doctype
21 document.documentElement // return whole html elements
22 document.documentURI // return current url
23 document.domain // like www.google.com
24 embeds // return all embeds elements <embeds src="">
25 document.forms | document.forms[0] | document.forms.item(0)
26 getElementById() // help to select element by id 
27 getElementsByClassName() // help to select element by class name
28 getElementsByName() // help to select element by name <input type="button" name="fname">
29 getElementsByTagName() // help to select element by tag name
30 hasFocus() // it retur true or flase
31 head // return head element 
32 images // return all dom <img /> elements
33 implementation // not that much usefull
34 document.importNode // help to import node from other frame and module
35 lastModified // this return last doc edit date
36 links // this return all <a /> elements
37 normalize() // this method removes empty text nodes
38 querySelector() // this return first elemnt 
39 querySelectorAll() // this return all element
40 readyState // return document current loading state
41 referrer // this return url which loaded current document
42 removeEventListerner // this method help to remove event on particular element you have to give event type and that function which is working with the event
43 scripts // this return script in html 
44  title // it retun title of documents
45 URL // return current url
46 write // document.write is use to jsx and simple text
47 writeInt // this is not overwrite all element this pust the jsx and text into html
-----------------------------@HTML_ELEMENT ------------------------
48 appendChild() // this method push element into selected element
49 attributes // this return all attributes of elements
50 focus // this method make focus on a desire element 
51 blur // this method make out of focus on focus element
52 childElementCount
53 children // this method return all child elemnt in selcted elemnt like document.body.children
54 childNodes // this element also return selected elements inside elements
55 classList // this help to add remove or toggle with extsting class
56 className // this change current class to assign
57 click() // this help to run click on any elemnt
58 clientHeight // this return height of selected element in px 
59 clientWidth // this return width of selected element in px
60 clientTop // this return top border width of selected element
61 clientLeft // this return left border width of selected element
62 cloneNode(true) // it return clone of selected element 
63 closest // this find closest match css selector element
64 compareDocumentPosition() // it compare elemnt position
65 conatins(element) // this return true or false id element inside a selected conatiner
66 contentEditable // this make selected element editable
67 dir // rtl ltr auto this method allow to to set direction of text
68 firstChild // this method help to select firect child element into selected element
69 firstElementChild // this method also return first element of selected element
70 getAttributes // this method return element from selector element
71 getAttributeNode // this method return element from selector element
72 getBoundingClientRect // getElementById('id').getBoundingClientRect().width | height | top | left | bottom | right
73 hasAttribute // hasAttribute('type') this method check attribute into a element
74 hasAttributes // this method check element have attribute or not
75 hasChildNodes // this method check element have child element or not
76 id // this return id value of element
77 innerHTML // this help to set innerHTML into 
77 innerText // this help to set innerText or get
78 insertAdjacentElement(position, element) // afterend | afterbegin | beforeend | beforebegin -- this method help to change posiion of element between each other
79 insertAbjacentHTML(postion ,HTML =) // afterend | afterbegin | beforeend | beforebegin -- this method help to change position of HTML
80 insertAbjacentText(postion ,HTML =) // afterend | afterbegin | beforeend | beforebegin -- this method help to change position of HTML
81 element.insertBefore(new, existing) =) 
82 isContentEditable // property returns true if the content of an element is editable. property is read-only.
83 isEqualNode() // this method check two element that are equal or not
84 isSameNode() // this method check two nodes are the same node.
86 lang // this method return the code of language
87 lastChild // this return last child of selected element
88 lastElementChild // this return last element from selected element
89 matches() // this method returns true if an element matches a specific CSS selector(s).
90 namespaceURI // property returns the URI of an elements namespace.
91 nextSibling // property returns the next node on the same tree level.
92 nextElementSibling // property returns the next element in the same tree level.
93 nodeName // this return  node tag name
94 nodeType // The nodeType property in DOM returns 1 for elements, 2 for attributes, 3 for text and 8 for comments.
95 nodeValue // property sets or returns the value of a node.
96 offsetHeight // return height of selected element with padding + border 
97 offsetWidth // return width of selected width padding + border
98 offsetParent // returns the nearest ancestor that has a position other than static.
99 offsetTop // return top position of element in px
100 offsetLeft // return left position of element in px
101 outerHTML // this replace selected element with give element
102 outerTExt // this replace selected element with given text
103 parentNode // this return parent node of slected element 
104 parentElement // this return parent element of selected element 
105 previousSibling // this return element of selected previos sibling node
105 previousElementSibling // this return previos element od selected element
106 querySelector() // this return first element
107 querySelectorAll() // this return array of element 
108 remove() // this method delete node from documents
109 removeAttribute() // this method remove attribute 
110 removeAtrributeNode() // this method remove attribute
111 removeChild(element) this method remove inside child element of parent element
112 replaceChild(newNode , currentElement) // this method replace child element with new element
113 scrollHeight //property returns the height of an element including padding, but excluding borders, scrollbars, or margins.
114 scrollIntoView // this make foucs on element where you want to make focus
115 scrollLeft // this method give you scroll in px like document.body 
116 scrollTop // this method is also give you scroll from top 
117 scrollWidth //property returns the width of an element including padding, but excluding borders, scrollbars, or margins.
118 setAttribute(type,value) // this mathod allow you to set attribute with value in element
119 setAttributeNode(type,value) // this method is also help to set attribute with value
120 textContent // this help to change text content

/**
-----------------------@NODE_JS --------------------------------------
@FS_Module
__dirname // this give file path without name of file
__filename // this give full path with file name also
path.join(__dirname,'..') // this method help to join path
mkdir(path[,{recursive:true}]) // Async create directory if recursion is true when folder is already there then mkdir replace that
readdir(path,{withFileTypes:true}) // this take path of folder which u want to read and return array of file name
rmdir(path,{recursive:true, maxLimit:num}) //if directory will not empty then u have to use recursive:true this method folder of given path. this return undefine
rm(path, {recursive:true}) // this method also work same as rmdir() above
writeFile(filename | filepath + filename, 'content of file', {option}) // this return undefine and create file on specify path
readFile(filename|filename+filepath, 'utf-8') // this will return buffer array if u not padd encoding 
appendFile(filename|filename+filepath,'content') // this will return undefined
copyFile(src,dest) // src- where u from want to copy | dest where u want to copy data or in which file / return undefine
stat(directorypath|filepath) // return file details and it have function also like isDirectory() isFile()
open 
read
close
existsSync() // check the folder is exsists or not
mkdirSync() // create folder sync 
read(buffer, offset, length, position)
write(buffer, offset[, length[, position]])
rename(oldPath, newPath)
*/
/**
---------------@Multer --------------------
upload = multer.diskStorage( { filename: (req, file, cb) => { return cb(error, filename)} ,
                        destination: (req, file, cb) =>{ return cb(error, path)}  } ) // this have 2 parameters fieldname | destination
upload = multer.memoryStorage()
multer({ dest|storage: string path | upload, 
        fileFilter: (req, file, cb)=>{ return cb(error , true)},
        limits:{ fieldNameSize : 100 , fieldSize: 1048576 (1mb), fields: infinity, fileSize: infinity, files: infinity, parts: infinity, headerPairs: 2000 },
        preservePath: ? })
multer().single('fieldName'); // this is use when u upload a single file
multer().array('fieldName',count of files u allow); // this is use when u upload multiple file from single field
multer().field({ name: fieldName, maxCount: count of files u allow }) // this is use when u have multi field and multi files
multer.none() // this use when u only want to get text data in req.body
multer.any() // accepts all files that comes from client
----------------------@Path ------------
__dirname
__filename
path.join()
path.extname()
path.relative(from, to)
path.normalize()
path.dirname(path+filename)
path.resolve(path) // give normal path
path.isAbsolute(path) // true | flase
*/

----------------------@Query_String --------------
const string = require('querystring')
string.stringify()
string.parse()
string.escape() // return  http%3A%2F%2Flocalhost%3A4000%2Fyes%3Fuser%3Dvikas%23dfdf
string.unescape(string.escape()) // return http://localhost:4000/yes?user=vikas#dfdf
string.encode()
string.decode()
*/

/**
---------------------@MongoDB ------------
@Data_Types_In_MongoDB

|--------------------------------------------------
@String : A string is a sequence of characters. Strings in MongoDB must be UTF-8 encoded.
@Integer : An integer is a whole number. Integers in MongoDB can be either 32-bit or 64-bit, depending on the server configuration.
@Double : A double is a floating-point number. Doubles in MongoDB have a precision of 16 digits.
@Boolean : A boolean is a value that can be either true or false.
@Array : An array is a collection of values. Arrays in MongoDB can contain any type of value, including other arrays.
@Object : An object is a collection of key-value pairs. Objects in MongoDB can be used to store complex data structures.
@Date : A date is a value that represents a point in time. Dates in MongoDB are stored in UTC.
@Null : A null value is a value that represents the absence of data.
@ObjectID : An ObjectID is a unique identifier for a document. ObjectIDs are 12-byte values that are generated by MongoDB.
@Binary : A binary is a sequence of bytes. Binaries in MongoDB can be used to store arbitrary data, such as images or files.
@Code : A code is a JavaScript function. Codes in MongoDB can be used to dynamically generate data or to perform complex operations.
@Regular  expression: A regular expression is a pattern that can be used to match text. Regular expressions in MongoDB can be used to search for and extract data from documents.
|--------------------------------------------------

@Query

|--------------------------------------------------

list of all query operators in MongoDB, according to the MongoDB documentation, with some details:

** @Comparison_Operators **
        @Notes ⚠⚠⚠⚠⚠ this operators is use as a ✨value checking✨ u can not pass in it ✨💀feild to check✨
* $eq: Equals 
* $ne: Not equal
* $gt: Greater than
* $gte: Greater than or equal to
* $lt: Less than
* $lte: Less than or equal to
* $in: In // []
* $nin: Not in // []
* $exists: Field exists // {field:{$exists:Boolean}}
* $type: Field type // {fieldL{$type:<String | number>}} // you have to choose type value from mongodb documents

** @Logical_Operators **

* $and: Logical AND // need all condition be true // { $and: [ { <expression1> }, { <expression2> } , ... , { <expressionN> } ] }
* $or: Logical OR // one condition be true // ({ $or: [ { <condition1> }, { <condition2> }, ... { <conditionN> } ] })
* $not: Logical NOT // { field: { $not: { <operator-expression> } } }
* $nor: Logical NOR // { $nor: [ { <expression1> }, { <expression2> }, ...  { <expressionN> } ] }

** @Evaluation_Operators **

* $expr: Evaluates an expression // { $expr: { $gt:[ 'field1', 'filed2' ] } } // this method compair two field
* $jsonSchema: Validates a document against a JSON schema // {$jsonSchema:{}}
* $mod: Modulo operation // 
* $regex: Regular expression match // {field:{$regex:String, options:"string"}}
* $text: Text search // to use this you have to createIndex of text for particular field { $text:{$search:"string", $caseSensitive:Boolean} }
* $where: Evaluates a JavaScript expression  //{ $where: <string|JavaScript Code> } // this operator work on javascript code

** @Element_Operators **
                        //📃 filed: [ {name:'vikas} ]
* $elemMatch: Matches elements in an array // { field: {$elemMatch: { name:/vik/i }} } it also work with array elelemnt
* $all: // this also work with array only it return all doc //{ <field>: { $all: [ <value1> , <value2> ... ] } }
* $size: Size of an array // ( { field: { $size: 2 } } ) -- sixe of array

** @Geospatial_Operators **
        @Notes 📝this operators is use to find geo location with after creating index of asphere
* $geoIntersects: Intersects a geospatial object with a geometry
* $geoWithin: Within a geospatial object
* $near: Near a geospatial object
* $nearSphere: Near a geospatial object (on a spherical surface)
* $box: A rectangular geospatial object
* $center: The center of a geospatial object
* $centerSphere: The center of a geospatial object (on a spherical surface)
* $geometry: A geospatial object
* $maxDistance: The maximum distance from a geospatial object
* $minDistance: The minimum distance from a geospatial object
* $polygon: A polygon geospatial object


** @Bitwise_Operators **

* $bitsAllClear: All bits in a value are clear
* $bitsAllSet: All bits in a value are set
* $bitsAnyClear: One or more bits in a value are clear
* $bitsAnySet: One or more bits in a value are set

** @Comment_Operators **

* $comment: A comment

** @Projection_Operators **
* $ // work with array {'<arrayFiled>.$' } // return array first element into query
* $elemMatch // { field: { $elemMatch: { <nested_field>: { <expression> : <value> } } } } // this only return a first layer nested filed
* $silce // { filed: { $slice: <number to show> || [ <number to skip> | <number to show> ]} }
?* $rand // return random float number between 0 to 1 

** @Field_Update_Operator **
* $currentDate * "$$NOW" * "$$CLUSTER_TIME" : { $current:Date:{ filed: true } } // it update filed with current date into ISO
* $min  : { $min: { field: number } } // it check field current value with seting value by you and then set min value 
* $max : { $max: { field: number } } // it check field current value with seting value by you and then set max value 
* $inc : { $inc: { filed: number } } // it increment filed value by number
* $mul : { $mul :{ filed: number } } // it multiply field value by number 📃 if type of value is Int32 it change Int64 according to number or if Int64 crosing number value it showing error
* $rename : { $rename: { filed_name: 'field_rename' } }
* $set : { $set: { filed: value } } // this set filed value if filed name is not in schema is return only 💡🆒{ acknowledge: fale } 💕 but create and set field value
* $setOnInsert : { $setOnInsert: { filed: value } } // this set filed value before return insert 
* $unset : { $unset: { field: '' } } // this delete field from the document

** @Array_Update_Operators **
* $ // updateOne( { <array>: value ... }, { $set: { "<array>.$" : value } } ) //:-- this change only a single array element 
* $[] // updateOne( { <array>: value ... }, { $set: { "<array>.$" : value } } ) //:-- this change all array element 
* $[<identifier>] // updateMany( {}, { $inc: { "grades.$[t].questions.$[score]": 2 } }, { arrayFilters: [ { "t.type": "quiz" }, { "score": { $gte: 8 } } ] } )
* $addToSet + $each // updateMany( {}, { $addToSet : { tags : { $each : [ 'elements' ] } } } )
* $pull // updateMany( {}, { $pull : { <Aray_filed>: value || condition } } ) // it also remove element from array as per give condition or value
* $push // updateMany( {}, { $push: { filed: { $each: [ "elements" ], $sort: -1 , $slice: 3 } } } ) //📃 sort : sort array 📃 slice: remove all element from array after giving value 📃 push method push all value into array
* $pop // updateMany( {}, { $pull : { <Aray_filed>: 1 || -1 } } ) // this only take 1 ot -1 value and remove first element from array and last element 😵 -1 remove start 😵 1 remove end
* $pullAll // updateMany( {}, { $pullAll : { filed: ["substract"] }} ) // pullAll get all matching value with pass filed array from current array
* $poistion // 😵 positive number remove start 😵 negative number remove end // updateMany( {}, { $push : { field:{ $each:  ["nahi", "sani"], $position: 0}}} ) it push on start of array

** @Aggregation_Pipeline_Stage **
* $addFields // aggregate( [ { $addFields:{ <name_of_field>: value } } ] ) // this method add new field into return document
* $sum // aggregate( [ { $addFields:{ <name_of_field>: { $sum: "$arrayFieldName" } } } ] ) // make total of array interger values
* $add // aggregate( [ { $addFields:{ <name_of_field>: { $add: [ "$fieldsName1", "fieldName2" ]  } } } ] ) // add two filed value
* $concatArrays // aggregate( [ { $addFields:{ <name_of_field>: { $concatArrays: [ "$arrayFieldName1", "$arrayFieldName2" ] } } } ] ) // concat two array

* $bucket
|--------------------------------------------------
        @Query : aggregate([{
                 $bucket: { groupBy: "$name", 
                            boundaries: [ "A", "D"  ],
                            default: "others",
                            output: { count: { $sum: 1 }, persons: { $push: { name: '$name'} } } } } ] )
        @Return : "data": [{
                                "_id": "A",
                                "count": 55,
                                "persons": [ ... ] },
                                {"_id": "others",
                                 "count": 192,
                                 "persons": [ ... ]}],
|--------------------------------------------------

* $concat: [ "$first_name", " ", "$last_name"] // this method merge two string 
?* $facet : db.aggregate( [ { $facet : { "customName": [ { <query> } ] } } ] ) // this method help to create multile pipeline in single affregate methods
* $bucketAuto : aggregate( [ { $bucketAuto: { groupBy: "$_id", buckets: 5, granularity: <granularity> } } ] ) // this method is also work as bucket 
?* $changeStream: 
?* $collStats: 
* $count: // { $count: <string> } // this method count the total document in return
?* $currentOp: 

* $densify // this methods use to fill the gap into documents. this only work with number
|--------------------------------------------------
        {
   $densify: {
      field: <fieldName>,
      partitionByFields: [ <field 1>, <field 2> ... <field n> ],
      range: {
         step: <number>,
         unit: <time unit>,
         bounds: < "full" || "partition" > || [ < lower bound >, < upper bound > ]
      }
   }
}
|--------------------------------------------------

?* $documents
* $fill // this method fill documents gap and also able to create new filed 

|--------------------------------------------------
        $fill: {
        partitionBy: <expression>, // optional 
        partitionByFields: [ <field 1>, <field 2>, ... , <field n> ], // optional
            sortBy: { // optional
               <sort field 1>: <sort order>,
               <sort field 2>: <sort order>,
               ...,
               <sort field n>: <sort order>
            }, 
            output: { // Required
               <field 1>: { value: <expression> },
               <field 2>: { method: <string> },
               ...
            } 
         }
|--------------------------------------------------

?* $geoNear
?* $graphLookup
* $group : // db.aggregate([ { $group: { _id: "$field", count: { $count: {} } } } ])  this methods make group of common field value 
?* $indexStats
?* $listLocalSessions
?* $listSessions
* $lookup // this method is useful when u have to look value into anthor collection 
|--------------------------------------------------
          $lookup:{
         from: <joined collection>,
         let: { <var_1>: <expression>, …, <var_n>: <expression> },
         pipeline: [ <pipeline to run on joined collection> ],
         as: <output array field>}

         $lookup:{
         from: <foreign collection>,
         localField: <field from local collection's documents>,
         foreignField: <field from foreign collection's documents>,
         let: { <var_1>: <expression>, …, <var_n>: <expression> },
         pipeline: [ <pipeline to run> ],
         as: <output array field>}
|--------------------------------------------------

* $match //this methods find all match field as per expression db.aggregate( [ { $match: { field : value } } ] )
?* $merge // this method merge to collection 🆒 it not return anyy thing
* $out // this methods create new collection if need also create new database according to coming data from aggregation
             { $out : { ?db:"new databse name", coll:" new collection name" } } 
?* $planCacheStats
* $project // { $project: { filed : true } } // this is help which kind of filed you want to show
?* $ redact
* $replaceRoot // { $replaceRoot: { newRoot: <replacementDocument> } } // this method allow you to create new data 
* $replaceWith // { $replaceWith:{ newRoot: "$Filed" } },
* $sample // { $sample: { size: number } } // this return random selected data from collection according to given size
?* $search
?* $searchMeta
* $set // { $set : { filed: "value || expression" } }
?* $setWindowDields
?* $shardedDataDistribution
* $skip // { $skip: number },
* $sort // { $sort: { field: 1 } }
* $unionWith // { $unionWith: { coll:"collection_name", pipleline: [... ] } } // this method merge two collection data with using pipeline you can do any thing with coming data from foreign collection
* $unset // { $unset:[ "field"] } // this method help to delete filed with value in aggregation
* $unwind // this method change array to object // { $unwind: { path: "field", includeArrayIndex: "arrayIndex" } }



|--------------------------------------------------
*/
